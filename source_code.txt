Project Path: 2zilmoon

Source Tree:

```txt
2zilmoon
‚îú‚îÄ‚îÄ app
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StakingNode
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ThemeInitializer.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ZilPayConnect
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ modals
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ account
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AccountCard.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Modal.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Skeleton.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Toggle.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TxCard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dex.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trim.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilliqa-stake-checker-client.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilliqa-stake-checker.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilpay-base.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ zilpay.ts
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ store
‚îÇ       ‚îú‚îÄ‚îÄ settings.ts
‚îÇ       ‚îú‚îÄ‚îÄ transactions.ts
‚îÇ       ‚îî‚îÄ‚îÄ wallet.tsx
‚îî‚îÄ‚îÄ next.config.ts

```

`2zilmoon/app/components/Header/index.tsx`:

```tsx
'use client';

import { useStore } from 'react-stores';
import styles from './Header.module.css';
import { ZilPayConnect } from '../ZilPayConnect';
import { $settings, updateSettingsStore, Themes } from '../../store/settings';

const Header = () => {
  const settings = useStore($settings);

  const toggleTheme = () => {
    const newTheme = settings.theme === Themes.Light ? Themes.Dark : Themes.Light;
    updateSettingsStore({ theme: newTheme });
  };

  return (
    <header className={styles.header}>
      <div className={styles.container}>
        <h1 className={styles.logo}>2zilmoon</h1>
        <div className={styles.controls}>
          <button 
            className={styles.themeToggle}
            onClick={toggleTheme}
            aria-label="Toggle theme"
          >
            {settings.theme === Themes.Light ? 'üåô' : '‚òÄÔ∏è'}
          </button>
          <ZilPayConnect />
        </div>
      </div>
    </header>
  );
};

export default Header;


```

`2zilmoon/app/components/StakingNode/index.tsx`:

```tsx
'use client';

import { useState } from 'react';
import styles from './StakingNode.module.css';
import { NodeStakeInfo } from '../../lib/zilliqa-stake-checker-client';
import { formatQaWithUnit, formatAddress, formatCommissionRate } from '../../lib/formatters';

interface StakingNodeProps {
  node: NodeStakeInfo;
  onClaim: (ssnAddress: string) => Promise<void>;
  onUnstake: () => void;
  isClaimLoading?: boolean;
}

const StakingNode: React.FC<StakingNodeProps> = ({ 
  node, 
  onClaim, 
  onUnstake, 
  isClaimLoading = false 
}) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const hasRewards = node.rewardsAmount > 0n;

  const handleClaimClick = async () => {
    if (isProcessing) return;
    
    setIsProcessing(true);
    try {
      await onClaim(node.ssnAddress);
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className={`${styles.card} animate-scale-in`}>
      <div className={styles.header}>
        <h3 className={styles.nodeName}>{node.ssnName}</h3>
        <span
          className={`${styles.statusBadge} ${
            node.status === '–ê–∫—Ç–∏–≤–µ–Ω' ? styles.statusActive : styles.statusInactive
          }`}
        >
          {node.status}
        </span>
      </div>

      <div className={styles.info}>
        <div className={styles.infoItem}>
          <span className={styles.infoLabel}>Node Address</span>
          <span className={`${styles.infoValue} ${styles.address}`} title={node.ssnAddress}>
            {formatAddress(node.ssnAddress, 8, 6)}
          </span>
        </div>

        <div className={styles.infoItem}>
          <span className={styles.infoLabel}>Commission Rate</span>
          <span className={`${styles.infoValue} ${styles.commission}`}>
            {formatCommissionRate(node.commissionRate)}
          </span>
        </div>
      </div>

      <div className={styles.metrics}>
        <div className={styles.metric}>
          <div className={styles.metricLabel}>Staked</div>
          <div
            className={`${styles.metricValue} ${styles.amount}`}
            title={`${node.stakeAmount.toString()} Qa`}
          >
            {formatQaWithUnit(node.stakeAmount)}
          </div>
        </div>

        <div className={styles.metric}>
          <div className={styles.metricLabel}>Rewards</div>
          <div
            className={`${styles.metricValue} ${styles.rewards}`}
            title={`${node.rewardsAmount.toString()} Qa`}
          >
            {formatQaWithUnit(node.rewardsAmount)}
          </div>
        </div>
      </div>

      <div className={styles.buttonContainer}>
        {hasRewards ? (
          <button 
            className={`${styles.button} ${styles.claimButton} ${
              isProcessing || isClaimLoading ? styles.loading : ''
            }`} 
            onClick={handleClaimClick}
            disabled={isProcessing || isClaimLoading}
          >
            {isProcessing || isClaimLoading ? (
              <span className={styles.loadingContent}>
                <span className={styles.spinner}></span>
                Processing...
              </span>
            ) : (
              'Claim Rewards'
            )}
          </button>
        ) : (
          <button 
            className={`${styles.button} ${styles.unstakeButton}`} 
            onClick={onUnstake}
          >
            Unstake
          </button>
        )}
      </div>
    </div>
  );
};

export default StakingNode;


```

`2zilmoon/app/components/ThemeInitializer.tsx`:

```tsx
'use client';

import { useEffect } from 'react';
import { initTheme } from '../store/settings';

export const ThemeInitializer = () => {
  useEffect(() => {
    initTheme();
  }, []);

  return null;
};

```

`2zilmoon/app/components/ZilPayConnect/index.tsx`:

```tsx
'use client';
import { useEffect, useState, useRef } from 'react';
import { useWallet } from '../../store/wallet';
import { zilPay } from '../../lib/zilpay';
import { formatAddress } from '../../lib/formatters';
import styles from './ZilPayConnect.module.css';

export const ZilPayConnect = () => {
  const { wallet, setWallet } = useWallet();
  const [connecting, setConnecting] = useState(false);
  const observerInitialized = useRef(false);

  useEffect(() => {
    if (observerInitialized.current) return;
    
    observerInitialized.current = true;
    zilPay.observable((account) => {
      if (account?.base16 != wallet?.base16) {
        setWallet(account);
      }
    });
  }, [setWallet]);

  const handleConnect = async () => {
    if (connecting) return;
    
    setConnecting(true);
    try {
      const connectedWallet = await zilPay.connect();
      setWallet(connectedWallet);
    } catch (error) {
      console.error('Failed to connect:', error);
    } finally {
      setConnecting(false);
    }
  };

  return (
    <button 
      className={`${styles.connectButton} ${
        wallet ? styles.connected : connecting ? styles.connecting : ''
      }`}
      onClick={handleConnect}
      disabled={connecting}
    >
      {wallet ? (
        <>
          <span className={styles.statusDot}></span>
          {formatAddress(wallet.bech32)}
        </>
      ) : connecting ? (
        'Connecting...'
      ) : (
        'Connect Wallet'
      )}
    </button>
  );
};


```

`2zilmoon/app/components/modals/account/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import { useStore } from "react-stores";
import { useTranslation } from "next-i18next";

import { Modal, ModalHeader } from "@/components/ui/Modal";
import { TxCard } from "@/components/ui/TxCard";
import { $transactions, resetTransactions } from "@/store/transactions";
import { AccountCard } from "@/components/ui/AccountCard";

import type { Wallet } from "@/lib/types";
import { $wallet } from "@/store/wallet";
import { Toggle } from "@/components/ui/Toggle";
import { $settings, updateSettingsStore } from "@/store/settings";
import { Themes } from "@/store/settings";

type Prop = {
  show: boolean;
  address: Wallet | null;
  onClose: () => void;
};


export var AccountModal: React.FC<Prop> = function ({
  show,
  onClose,
  address
}) {
  const common = useTranslation(`common`);
  const { transactions } = useStore($transactions);
  const wallet = useStore($wallet);
  const settings = useStore($settings);

  const hanldeChangeTheme = React.useCallback((value: boolean) => {
    if (value) {
      updateSettingsStore({
        ...settings,
        theme: Themes.Dark
      });
    } else {
      updateSettingsStore({
        ...settings,
        theme: Themes.Light
      });
    }
  }, [settings]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`account`)}
        </ModalHeader>
      )}
      width="450px"
      onClose={onClose}
    >
      <AccountCard wallet={address} />
      <div className={styles.txlist}>
        <Toggle
          value={settings.theme === Themes.Dark}
          onToggle={hanldeChangeTheme}
        />
        {transactions.length === 0 ? (
          <p className={styles.here}>
            {common.t(`tx_appear_here`)}
          </p>
        ) : (
          <div>
            <div className={styles.header}>
              <p>
                {common.t(`recent_txns`)}
              </p>
              <p
                className={styles.clear}
                onClick={() => resetTransactions(String(wallet?.bech32))}
              >
                (
                {common.t(`clear_all`)}
                )
              </p>
            </div>
            {transactions.map((tx) => (
              <TxCard key={tx.hash} tx={tx} />
            ))}
          </div>
        )}
      </div>
    </Modal>
  );
};

```

`2zilmoon/app/components/ui/AccountCard.tsx`:

```tsx
import React from 'react';

interface AccountCardProps {
  wallet: any; // Replace 'any' with your actual wallet type
}

export const AccountCard: React.FC<AccountCardProps> = ({ wallet }) => {
  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
      <p>Address: {wallet?.bech32}</p>
      <p>Balance: ...</p>
    </div>
  );
};

```

`2zilmoon/app/components/ui/Modal.tsx`:

```tsx
import React from 'react';

interface ModalProps {
  show: boolean;
  title: React.ReactNode;
  width?: string;
  onClose: () => void;
}

export const Modal: React.FC<ModalProps> = ({ show, title, width, onClose, children }) => {
  if (!show) return null;

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 1000 }}>
      <div style={{ backgroundColor: 'white', padding: '20px', borderRadius: '8px', width: width || 'auto', position: 'relative' }}>
        {title}
        <button onClick={onClose} style={{ position: 'absolute', top: '10px', right: '10px', background: 'none', border: 'none', fontSize: '1.2em', cursor: 'pointer' }}>&times;</button>
        {children}
      </div>
    </div>
  );
};

interface ModalHeaderProps {
  onClose: () => void;
}

export const ModalHeader: React.FC<ModalHeaderProps> = ({ onClose, children }) => {
  return (
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
      <h2>{children}</h2>
    </div>
  );
};

```

`2zilmoon/app/components/ui/Skeleton.tsx`:

```tsx
import React from 'react';
import styles from './Skeleton.module.css';

interface SkeletonProps {
  className?: string;
  width?: string | number;
  height?: string | number;
  borderRadius?: string;
  count?: number;
}

export const Skeleton: React.FC<SkeletonProps> = ({
  className = '',
  width,
  height = '1rem',
  borderRadius = '4px',
  count = 1,
}) => {
  const skeletonStyle = {
    width,
    height,
    borderRadius,
  };

  if (count === 1) {
    return (
      <div 
        className={`${styles.skeleton} ${className}`}
        style={skeletonStyle}
      />
    );
  }

  return (
    <>
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={`${styles.skeleton} ${className}`}
          style={skeletonStyle}
        />
      ))}
    </>
  );
};

export const SkeletonCard: React.FC = () => (
  <div className={styles.skeletonCard}>
    <div className={styles.cardHeader}>
      <Skeleton height="24px" width="60%" />
      <Skeleton height="20px" width="80px" borderRadius="20px" />
    </div>
    <div className={styles.cardInfo}>
      <div className={styles.infoRow}>
        <Skeleton height="16px" width="40%" />
        <Skeleton height="16px" width="50%" />
      </div>
      <div className={styles.infoRow}>
        <Skeleton height="16px" width="35%" />
        <Skeleton height="16px" width="45%" />
      </div>
    </div>
    <div className={styles.cardMetrics}>
      <div className={styles.metric}>
        <Skeleton height="14px" width="60px" />
        <Skeleton height="20px" width="80px" />
      </div>
      <div className={styles.metric}>
        <Skeleton height="14px" width="60px" />
        <Skeleton height="20px" width="80px" />
      </div>
    </div>
    <Skeleton height="40px" width="100%" borderRadius="8px" />
  </div>
);

export const SkeletonSummary: React.FC = () => (
  <div className={styles.skeletonSummary}>
    <Skeleton height="32px" width="300px" className={styles.title} />
    <div className={styles.statsGrid}>
      {Array.from({ length: 3 }).map((_, index) => (
        <div key={index} className={styles.statCard}>
          <Skeleton height="16px" width="80px" />
          <Skeleton height="28px" width="120px" />
        </div>
      ))}
    </div>
  </div>
);


```

`2zilmoon/app/components/ui/Toggle.tsx`:

```tsx
import React from 'react';

interface ToggleProps {
  value: boolean;
  onToggle: (value: boolean) => void;
}

export const Toggle: React.FC<ToggleProps> = ({ value, onToggle }) => {
  return (
    <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
      <input
        type="checkbox"
        checked={value}
        onChange={(e) => onToggle(e.target.checked)}
        style={{ marginRight: '8px' }}
      />
      <span>{value ? 'Dark Mode' : 'Light Mode'}</span>
    </label>
  );
};

```

`2zilmoon/app/components/ui/TxCard.tsx`:

```tsx
import React from 'react';

interface TxCardProps {
  tx: any; // Replace 'any' with your actual transaction type
}

export const TxCard: React.FC<TxCardProps> = ({ tx }) => {
  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
      <p>Hash: {tx.hash}</p>
      <p>Confirmed: {tx.confirmed ? 'Yes' : 'No'}</p>
      {tx.error && <p style={{ color: 'red' }}>Error: {tx.error}</p>}
    </div>
  );
};

```

`2zilmoon/app/layout.tsx`:

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { WalletProvider } from './store/wallet';
import { ThemeInitializer } from './components/ThemeInitializer'; 

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "2zilmoon",
  description: "Zilliqa Staking Migration",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ThemeInitializer /> 
        <WalletProvider>
          {children}
        </WalletProvider>
      </body>
    </html>
  );
}

```

`2zilmoon/app/lib/dex.ts`:

```ts
export class DragonDex {
  updateTokens() {
    // Placeholder for updating tokens logic
    console.log('DragonDex: updateTokens called');
  }

  updateState() {
    // Placeholder for updating DEX state logic
    console.log('DragonDex: updateState called');
  }
}
```

`2zilmoon/app/lib/formatters.ts`:

```ts
// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Qa –≤ ZIL (1 ZIL = 10^12 Qa)
const QA_TO_ZIL = 1000000000000n;

export const formatQaToZil = (qa: bigint): string => {
  const zil = Number(qa) / Number(QA_TO_ZIL);
  
  if (zil === 0) return '0';
  
  const formatter = new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 0,
    maximumFractionDigits: zil < 1 ? 6 : 2,
  });
  
  return formatter.format(zil);
};

export const formatQaWithUnit = (qa: bigint, showUnit: boolean = true): string => {
  const zil = formatQaToZil(qa);
  return showUnit ? `${zil} ZIL` : zil;
};

export const formatLargeNumber = (value: bigint): string => {
  const num = Number(value);
  
  if (num >= 1e9) {
    return new Intl.NumberFormat('en-US', {
      notation: 'compact',
      compactDisplay: 'short',
      maximumFractionDigits: 2
    }).format(num);
  }
  
  return new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 0
  }).format(num);
};

export const formatAddress = (address: string, startChars: number = 6, endChars: number = 4): string => {
  if (!address || address.length <= startChars + endChars) {
    return address;
  }
  return `${address.substring(0, startChars)}...${address.substring(address.length - endChars)}`;
};

export const formatCommissionRate = (rate: bigint): string => {
  const rateNumber = Number(rate) / 10000000;
  return new Intl.NumberFormat('en-US', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(rateNumber / 100);
};

export const formatUSD = (amount: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
};


```

`2zilmoon/app/lib/trim.ts`:

```ts
export function trim(str: string, len = 10) {
  const half = Math.floor(len / 2);
  return `${str.slice(0, half)}...${str.slice(str.length - half, str.length)}`;
}

```

`2zilmoon/app/lib/types.ts`:

```ts
export interface Wallet {
  base16: string;
  bech32: string;
}

```

`2zilmoon/app/lib/zilliqa-stake-checker-client.ts`:

```ts
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è Mainnet
const MAINNET_CONFIG = {
    api: 'https://api.zilliqa.com',
    impl: '0xa7C67D49C82c7dc1B73D231640B2e4d0661D37c1',
    chainId: 1
};

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
export interface NodeStakeInfo {
    ssnName: string;
    ssnAddress: string;
    stakeAmount: bigint;
    rewardsAmount: bigint;
    commissionRate: bigint;
    status: string;
}

export interface BatchQueryResult {
    id: number;
    result: any;
    jsonrpc?: string;
}

export interface RewardCalculationData {
    lastRewardCycle: number;
    lastWithdrawCycleMap: any;
    stakeSsnPerCycleMaps: { [ssnAddress: string]: any };
    directDepositMaps: { [ssnAddress: string]: any };
    buffDepositMaps: { [ssnAddress: string]: any };
    delegStakePerCycleMaps: { [ssnAddress: string]: any };
}

export interface StakedNodesSummary {
    nodes: NodeStakeInfo[];
    totalStaked: bigint;
    totalRewards: bigint;
    totalNodes: number;
}

export class ZilliqaStakeChecker {
    private apiUrl: string;
    private implAddress: string;

    constructor() {
        this.apiUrl = MAINNET_CONFIG.api;
        this.implAddress = MAINNET_CONFIG.impl;
    }

    private async batchQuery(queries: Array<[string, string, any[]]>): Promise<BatchQueryResult[]> {
        if (queries.length === 0) return [];
        const requestBody = queries.map((query, index) => ({
            jsonrpc: '2.0',
            id: index + 1,
            method: 'GetSmartContractSubState',
            params: [
                query[0],
                query[1],
                query[2]
            ]
        }));

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: ${response.status} ${response.statusText}`);
            }

            const jsonResponse: BatchQueryResult[] | {error: any} = await response.json();
            
            if (!Array.isArray(jsonResponse)) {
                 if (jsonResponse.error) {
                    throw new Error(`–û—à–∏–±–∫–∞ RPC: ${jsonResponse.error.message}`);
                 }
                throw new Error('–û—Ç–≤–µ—Ç –æ—Ç API –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º, –∫–∞–∫ –æ–∂–∏–¥–∞–ª–æ—Å—å –¥–ª—è batch-–∑–∞–ø—Ä–æ—Å–∞.');
            }
            
            return jsonResponse.sort((a, b) => a.id - b.id);
            
        } catch (error) {
            throw error;
        }
    }

    private normalizeAddress(address: string): string {
        if (!/^0x[0-9a-f]{40}$/i.test(address)) {
            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–¥—Ä–µ—Å–∞: ${address}. –û–∂–∏–¥–∞–µ—Ç—Å—è hex-–∞–¥—Ä–µ—Å —Ñ–æ—Ä–º–∞—Ç–∞ 0x...`);
        }
        return address.toLowerCase();
    }

    private async calculateRewards(normalizedAddress: string, userDeposits: { [ssn: string]: string }, rewardData: RewardCalculationData): Promise<{ [ssnAddress: string]: bigint }> {
        const rewardsBySsn: { [ssnAddress: string]: bigint } = {};

        for (const ssnAddress of Object.keys(userDeposits)) {
            let totalSsnReward = 0n;

            try {
                const lastWithdrawCycle = parseInt(rewardData.lastWithdrawCycleMap?.last_withdraw_cycle_deleg?.[normalizedAddress]?.[ssnAddress] || '0');
                const cyclesToCalculate = [];
                for (let i = lastWithdrawCycle + 1; i <= rewardData.lastRewardCycle; i++) {
                    cyclesToCalculate.push(i);
                }

                if (cyclesToCalculate.length === 0) {
                    rewardsBySsn[ssnAddress] = 0n;
                    continue;
                }

                const delegStakePerCycleMap = new Map<number, bigint>();
                const directMap = rewardData.directDepositMaps[ssnAddress]?.direct_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};
                const buffMap = rewardData.buffDepositMaps[ssnAddress]?.buff_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};

                for (let cycle = 1; cycle <= rewardData.lastRewardCycle; cycle++) {
                    const c1 = cycle - 1;
                    const c2 = cycle - 2;
                    const dir_amt = BigInt(directMap[c1.toString()] || 0);
                    const buf_amt = BigInt(buffMap[c2.toString()] || 0);
                    const last_amt = delegStakePerCycleMap.get(c1) || 0n;
                    const total_amt = last_amt + dir_amt + buf_amt;
                    delegStakePerCycleMap.set(cycle, total_amt);
                }

                const ssnCycleInfoMap = rewardData.stakeSsnPerCycleMaps[ssnAddress]?.stake_ssn_per_cycle?.[ssnAddress] || {};

                for (const cycle of cyclesToCalculate) {
                    const cycleInfo = ssnCycleInfoMap[cycle];
                    if (!cycleInfo) continue;

                    const totalRewardsForCycle = BigInt(cycleInfo.arguments[1]);
                    const totalStakeForCycle = BigInt(cycleInfo.arguments[0]);
                    const delegStakeForCycle = delegStakePerCycleMap.get(cycle);

                    if (delegStakeForCycle && delegStakeForCycle > 0n && totalStakeForCycle > 0n) {
                        const cycleReward = (delegStakeForCycle * totalRewardsForCycle) / totalStakeForCycle;
                        totalSsnReward += cycleReward;
                    }
                }
            } catch (e) {
                totalSsnReward = 0n;
            }

            rewardsBySsn[ssnAddress] = totalSsnReward;
        }
        
        return rewardsBySsn;
    }

    async getStakedNodes(walletAddress: string): Promise<StakedNodesSummary> {
        const normalizedAddress = this.normalizeAddress(walletAddress);

        const initialQueries: Array<[string, string, any[]]> = [
            [this.implAddress, 'deposit_amt_deleg', [normalizedAddress]],
            [this.implAddress, 'ssnlist', []],
            [this.implAddress, 'lastrewardcycle', []],
            [this.implAddress, 'last_withdraw_cycle_deleg', [normalizedAddress]],
        ];

        try {
            const initialResults = await this.batchQuery(initialQueries);
            
            const depositsResult = initialResults[0]?.result;
            const ssnListResult = initialResults[1]?.result;
            const lastRewardCycleResult = initialResults[2]?.result;
            const lastWithdrawResult = initialResults[3]?.result;

            if (!depositsResult || !ssnListResult || !lastRewardCycleResult) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            }

            const userDeposits = depositsResult.deposit_amt_deleg?.[normalizedAddress];
            
            if (!userDeposits || Object.keys(userDeposits).length === 0) {
                return {
                    nodes: [],
                    totalStaked: 0n,
                    totalRewards: 0n,
                    totalNodes: 0,
                };
            }
            
            const ssnList = ssnListResult.ssnlist;
            if (!ssnList) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤');

            const rewardQueries: Array<[string, string, any[]]> = [];
            const stakedSsnAddresses = Object.keys(userDeposits);

            for (const ssnAddr of stakedSsnAddresses) {
                rewardQueries.push([this.implAddress, 'stake_ssn_per_cycle', [ssnAddr]]);
                rewardQueries.push([this.implAddress, 'direct_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'buff_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'deleg_stake_per_cycle', [normalizedAddress, ssnAddr]]);
            }

            const rewardQueryResults = await this.batchQuery(rewardQueries);
            
            const rewardData: RewardCalculationData = {
                lastRewardCycle: parseInt(lastRewardCycleResult.lastrewardcycle),
                lastWithdrawCycleMap: lastWithdrawResult,
                stakeSsnPerCycleMaps: {},
                directDepositMaps: {},
                buffDepositMaps: {},
                delegStakePerCycleMaps: {},
            };
            
            let queryIndex = 0;
            for (const ssnAddr of stakedSsnAddresses) {
                rewardData.stakeSsnPerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.directDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.buffDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.delegStakePerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
            }
            
            const rewardsBySsn = await this.calculateRewards(normalizedAddress, userDeposits, rewardData);

            const stakedNodes: NodeStakeInfo[] = [];
            let totalStaked = 0n;
            let totalRewards = 0n;

            for (const [ssnAddress, stakeAmountStr] of Object.entries(userDeposits)) {
                const ssnInfo = ssnList[ssnAddress];
                
                if (!ssnInfo) {
                    continue;
                }

                const ssnArgs = ssnInfo.arguments;
                const ssnName = ssnArgs[3] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                const commissionRate = BigInt(ssnArgs[7] || '0');
                const isActive = ssnArgs[0]?.constructor === 'True';
                const status = isActive ? '–ê–∫—Ç–∏–≤–µ–Ω' : '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω';
                
                const stakeAmount = BigInt(stakeAmountStr as string);
                const rewardsAmount = rewardsBySsn[ssnAddress] || 0n;
                
                totalStaked += stakeAmount;
                totalRewards += rewardsAmount;

                const nodeInfo: NodeStakeInfo = { ssnName, ssnAddress: `0x${ssnAddress}`, stakeAmount, rewardsAmount, commissionRate, status };
                stakedNodes.push(nodeInfo);
            }

            return {
                nodes: stakedNodes,
                totalStaked: totalStaked,
                totalRewards: totalRewards,
                totalNodes: stakedNodes.length,
            };

        } catch (error) {
            throw error;
        }
    }
}
```

`2zilmoon/app/lib/zilliqa-stake-checker.ts`:

```ts
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è Mainnet
const MAINNET_CONFIG = {
    api: 'https://api.zilliqa.com',
    impl: '0xa7C67D49C82c7dc1B73D231640B2e4d0661D37c1', // Mainnet staking contract
    chainId: 1
};

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
export interface NodeStakeInfo {
    ssnName: string;
    ssnAddress: string;
    stakeAmount: bigint;
    rewardsAmount: bigint;
    commissionRate: bigint;
    status: string;
}

// –≠—Ç–æ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–¥–µ–∞–ª—å–Ω–æ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ñ–æ—Ä–º–∞—Ç–æ–º –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ batch-–æ—Ç–≤–µ—Ç–µ
interface BatchQueryResult {
    id: number;
    result: any;
    jsonrpc?: string; // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã
}

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –¥–∞–Ω–Ω—ã—Ö, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω–∞–≥—Ä–∞–¥
interface RewardCalculationData {
    lastRewardCycle: number;
    lastWithdrawCycleMap: any;
    stakeSsnPerCycleMaps: { [ssnAddress: string]: any };
    directDepositMaps: { [ssnAddress: string]: any };
    buffDepositMaps: { [ssnAddress: string]: any };
    delegStakePerCycleMaps: { [ssnAddress: string]: any };
}

export class ZilliqaStakeChecker {
    private apiUrl: string;
    private implAddress: string;

    constructor() {
        this.apiUrl = MAINNET_CONFIG.api;
        this.implAddress = MAINNET_CONFIG.impl;
    }

    private async batchQuery(queries: Array<[string, string, any[]]>): Promise<BatchQueryResult[]> {
        if (queries.length === 0) return [];
        const startTime = performance.now();

        const requestBody = queries.map((query, index) => ({
            jsonrpc: '2.0',
            id: index + 1,
            method: 'GetSmartContractSubState',
            params: [
                query[0],
                query[1],
                query[2]
            ]
        }));

        try {
            console.log(` –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è batch –∑–∞–ø—Ä–æ—Å (${queries.length} –∑–∞–ø—Ä–æ—Å–æ–≤) —á–µ—Ä–µ–∑ fetch (—Å—Ç–∞–Ω–¥–∞—Ä—Ç JSON-RPC 2.0)...`);
            
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: ${response.status} ${response.statusText}`);
            }

            const jsonResponse: BatchQueryResult[] | {error: any} = await response.json();
            
            if (!Array.isArray(jsonResponse)) {
                 if (jsonResponse.error) {
                    throw new Error(`–û—à–∏–±–∫–∞ RPC: ${jsonResponse.error.message}`);
                 }
                throw new Error('–û—Ç–≤–µ—Ç –æ—Ç API –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º, –∫–∞–∫ –æ–∂–∏–¥–∞–ª–æ—Å—å –¥–ª—è batch-–∑–∞–ø—Ä–æ—Å–∞.');
            }

            const endTime = performance.now();
            console.log(`‚úÖ Batch –∑–∞–ø—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω –∑–∞ ${((endTime - startTime) / 1000).toFixed(2)}—Å`);
            
            return jsonResponse.sort((a, b) => a.id - b.id);
            
        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –≤ batch –∑–∞–ø—Ä–æ—Å–µ:', error);
            throw error;
        }
    }

    private normalizeAddress(address: string): string {
        if (!/^0x[0-9a-f]{40}$/i.test(address)) {
            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–¥—Ä–µ—Å–∞: ${address}. –û–∂–∏–¥–∞–µ—Ç—Å—è hex-–∞–¥—Ä–µ—Å —Ñ–æ—Ä–º–∞—Ç–∞ 0x...`);
        }
        return address.toLowerCase();
    }

    private async calculateRewards(normalizedAddress: string, userDeposits: { [ssn: string]: string }, rewardData: RewardCalculationData): Promise<{ [ssnAddress: string]: bigint }> {
        console.log(`
 –†–∞—Å—á–µ—Ç –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥ (–≤ Qa)...`);
        const rewardsBySsn: { [ssnAddress: string]: bigint } = {};

        for (const ssnAddress of Object.keys(userDeposits)) {
            let totalSsnReward = 0n;

            try {
                const lastWithdrawCycle = parseInt(rewardData.lastWithdrawCycleMap?.last_withdraw_cycle_deleg?.[normalizedAddress]?.[ssnAddress] || '0');
                const cyclesToCalculate = [];
                for (let i = lastWithdrawCycle + 1; i <= rewardData.lastRewardCycle; i++) {
                    cyclesToCalculate.push(i);
                }

                if (cyclesToCalculate.length === 0) {
                    rewardsBySsn[ssnAddress] = 0n;
                    continue;
                }

                const delegStakePerCycleMap = new Map<number, bigint>();
                const directMap = rewardData.directDepositMaps[ssnAddress]?.direct_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};
                const buffMap = rewardData.buffDepositMaps[ssnAddress]?.buff_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};

                for (let cycle = 1; cycle <= rewardData.lastRewardCycle; cycle++) {
                    const c1 = cycle - 1;
                    const c2 = cycle - 2;
                    const dir_amt = BigInt(directMap[c1.toString()] || 0);
                    const buf_amt = BigInt(buffMap[c2.toString()] || 0);
                    const last_amt = delegStakePerCycleMap.get(c1) || 0n;
                    const total_amt = last_amt + dir_amt + buf_amt;
                    delegStakePerCycleMap.set(cycle, total_amt);
                }

                const ssnCycleInfoMap = rewardData.stakeSsnPerCycleMaps[ssnAddress]?.stake_ssn_per_cycle?.[ssnAddress] || {};

                for (const cycle of cyclesToCalculate) {
                    const cycleInfo = ssnCycleInfoMap[cycle];
                    if (!cycleInfo) continue;

                    const totalRewardsForCycle = BigInt(cycleInfo.arguments[1]);
                    const totalStakeForCycle = BigInt(cycleInfo.arguments[0]);
                    const delegStakeForCycle = delegStakePerCycleMap.get(cycle);

                    if (delegStakeForCycle && delegStakeForCycle > 0n && totalStakeForCycle > 0n) {
                        const cycleReward = (delegStakeForCycle * totalRewardsForCycle) / totalStakeForCycle;
                        totalSsnReward += cycleReward;
                    }
                }
            } catch (e) {
                console.error(`- –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –Ω–∞–≥—Ä–∞–¥ –¥–ª—è —É–∑–ª–∞ ${ssnAddress}:`, e);
                totalSsnReward = 0n;
            }

            rewardsBySsn[ssnAddress] = totalSsnReward;
        }
        
        console.log(`‚úÖ –†–∞—Å—á–µ—Ç –Ω–∞–≥—Ä–∞–¥ –∑–∞–≤–µ—Ä—à–µ–Ω.`);
        return rewardsBySsn;
    }

    async getStakedNodes(walletAddress: string): Promise<NodeStakeInfo[]> {
        console.log(`
 –ü–æ–∏—Å–∫ —Å—Ç–µ–π–∫–æ–≤ –¥–ª—è –∞–¥—Ä–µ—Å–∞: ${walletAddress}`);
        const normalizedAddress = this.normalizeAddress(walletAddress);
        console.log(` –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å: ${normalizedAddress}`);

        const initialQueries: Array<[string, string, any[]]> = [
            [this.implAddress, 'deposit_amt_deleg', [normalizedAddress]],
            [this.implAddress, 'ssnlist', []],
            [this.implAddress, 'lastrewardcycle', []],
            [this.implAddress, 'last_withdraw_cycle_deleg', [normalizedAddress]],
        ];

        try {
            const initialResults = await this.batchQuery(initialQueries);
            
            const depositsResult = initialResults[0]?.result;
            const ssnListResult = initialResults[1]?.result;
            const lastRewardCycleResult = initialResults[2]?.result;
            const lastWithdrawResult = initialResults[3]?.result;

            if (!depositsResult || !ssnListResult || !lastRewardCycleResult) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            }

            const userDeposits = depositsResult.deposit_amt_deleg?.[normalizedAddress];
            
            if (!userDeposits || Object.keys(userDeposits).length === 0) {
                console.log('‚ùå –£ –¥–∞–Ω–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç–µ–π–∫–æ–≤');
                return [];
            }
            
            const ssnList = ssnListResult.ssnlist;
            if (!ssnList) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤');

            const rewardQueries: Array<[string, string, any[]]> = [];
            const stakedSsnAddresses = Object.keys(userDeposits);

            for (const ssnAddr of stakedSsnAddresses) {
                rewardQueries.push([this.implAddress, 'stake_ssn_per_cycle', [ssnAddr]]);
                rewardQueries.push([this.implAddress, 'direct_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'buff_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'deleg_stake_per_cycle', [normalizedAddress, ssnAddr]]);
            }

            const rewardQueryResults = await this.batchQuery(rewardQueries);
            
            const rewardData: RewardCalculationData = {
                lastRewardCycle: parseInt(lastRewardCycleResult.lastrewardcycle),
                lastWithdrawCycleMap: lastWithdrawResult,
                stakeSsnPerCycleMaps: {},
                directDepositMaps: {},
                buffDepositMaps: {},
                delegStakePerCycleMaps: {},
            };
            
            let queryIndex = 0;
            for (const ssnAddr of stakedSsnAddresses) {
                rewardData.stakeSsnPerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.directDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.buffDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.delegStakePerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
            }
            
            const rewardsBySsn = await this.calculateRewards(normalizedAddress, userDeposits, rewardData);

            console.log(`
 –ù–∞–π–¥–µ–Ω–æ —Å—Ç–µ–π–∫–æ–≤ –Ω–∞ ${Object.keys(userDeposits).length} —É–∑–ª–∞—Ö:`);
            console.log('='.repeat(81));

            const stakedNodes: NodeStakeInfo[] = [];
            let totalStaked = 0n;
            let totalRewards = 0n;

            for (const [ssnAddress, stakeAmountStr] of Object.entries(userDeposits)) {
                const ssnInfo = ssnList[ssnAddress];
                
                if (!ssnInfo) {
                    console.log(`‚ö†Ô∏è  –£–∑–µ–ª 0x${ssnAddress} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ`);
                    continue;
                }

                const ssnArgs = ssnInfo.arguments;
                const ssnName = ssnArgs[3] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                const commissionRate = BigInt(ssnArgs[7] || '0');
                const isActive = ssnArgs[0]?.constructor === 'True';
                const status = isActive ? '–ê–∫—Ç–∏–≤–µ–Ω' : '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω';
                
                const stakeAmount = BigInt(stakeAmountStr as string);
                const rewardsAmount = rewardsBySsn[ssnAddress] || 0n;
                
                totalStaked += stakeAmount;
                totalRewards += rewardsAmount;

                const nodeInfo: NodeStakeInfo = { ssnName, ssnAddress: `0x${ssnAddress}`, stakeAmount, rewardsAmount, commissionRate, status };
                stakedNodes.push(nodeInfo);

                console.log(`
 –£–∑–µ–ª: ${ssnName}`);
                console.log(`     –ê–¥—Ä–µ—Å: 0x${ssnAddress}`);
                console.log(`     –°—Ç–µ–π–∫ (Qa): ${stakeAmount.toString()}`);
                console.log(`     –ù–∞–≥—Ä–∞–¥—ã (Qa): ${rewardsAmount.toString()}`);
                console.log(`     –ö–æ–º–∏—Å—Å–∏—è (10^7): ${commissionRate.toString()}`);
                console.log(`     –°—Ç–∞—Ç—É—Å: ${status}`);
            }

            console.log(`
${'='.repeat(81)}`);
            console.log(` –û–ë–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:`);
            console.log(`     –í—Å–µ–≥–æ —É–∑–ª–æ–≤ —Å–æ —Å—Ç–µ–π–∫–æ–º: ${stakedNodes.length}`);
            console.log(`     –û–±—â–∞—è —Å—É–º–º–∞ —Å—Ç–µ–π–∫–∞ (Qa): ${totalStaked.toString()}`);
            console.log(`     –û–±—â–∞—è —Å—É–º–º–∞ –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥ (Qa): ${totalRewards.toString()}`);
            console.log(`     –°–µ—Ç—å: Mainnet`);
            console.log('='.repeat(81));

            return stakedNodes;

        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–µ–π–∫–æ–≤:', error);
            throw error;
        }
    }
}
```

`2zilmoon/app/lib/zilpay-base.ts`:

```ts
import { ZilPay } from "@zilliqa-js/zilliqa";

export class ZilPayBase {
  public zilpay = () => new ZilPay();
}

```

`2zilmoon/app/lib/zilpay.ts`:

```ts
'use client';
import { Wallet } from './types';
declare global {
  interface Window {
    zilPay: any;
  }
}

export const zilPay = {
  crypto: {
    fromBech32Address: (bech32Address: string) => {
      if (typeof window === 'undefined' || !window.zilPay || !window.zilPay.crypto) {
        throw new Error('ZilPay crypto object not available.');
      }
      return window.zilPay.crypto.fromBech32Address(bech32Address);
    },
  },
  connect: async (): Promise<Wallet | null> => {
    try {
      const zilPay = await getZilPay();
      const connected = await zilPay.wallet.connect();
      if (connected && zilPay.wallet.defaultAccount) {
        return zilPay.wallet.defaultAccount;
      }
      return null;
    } catch (error) {
      console.error('Failed to connect to ZilPay:', error);
      return null;
    }
  },
  callTransaction: async (
    contractAddress: string,
    data: any,
    amount: string = '0',
    gasPrice: number = 2000000000,
    gasLimit: number = 10000,
  ) => {
    const zilPay = await getZilPay();
    const { contracts, utils } = zilPay;
    const contract = contracts.at(contractAddress);
    const { BN } = utils;

    return await contract.call(
      data._tag,
      data.params,
      {
        amount: new BN(amount),
        gasPrice: new BN(gasPrice),
        gasLimit: new BN(gasLimit),
      },
      true,
    );
  },
  observable: (callback: (wallet: Wallet | null) => void) => {
    getZilPay().then((zilPay) => {
      if (zilPay.wallet.defaultAccount) {
        callback(zilPay.wallet.defaultAccount);
      }
      zilPay.wallet.observableAccount().subscribe((account: Wallet) => {
        callback(account);
      });
    });
  },
};

function getZilPay(): Promise<any> {
  return new Promise((resolve, reject) => {
    if (typeof window === 'undefined') {
      return reject('Window is not defined');
    }
    let k = 0;
    const i = setInterval(() => {
      if (k >= 10) {
        clearInterval(i);
        return reject(new Error(`ZilPay is not installed.`));
      }
      if (typeof window.zilPay !== `undefined`) {
        clearInterval(i);
        return resolve(window.zilPay);
      }
      k++;
    }, 100);
  });
}

```

`2zilmoon/app/page.tsx`:

```tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { useWallet } from './store/wallet';
import Header from './components/Header';
import StakingNode from './components/StakingNode';
import { SkeletonCard, SkeletonSummary } from './components/ui/Skeleton';
import styles from './page.module.css';
import { ZilliqaStakeChecker, StakedNodesSummary } from './lib/zilliqa-stake-checker-client';
import { formatQaWithUnit } from './lib/formatters';
import { zilPay } from './lib/zilpay';
import { updateTransactions } from './store/transactions';

const StakingPage = () => {
  const { wallet } = useWallet();
  const [manualWalletAddress, setManualWalletAddress] = useState<string>('');
  const [stakingSummary, setStakingSummary] = useState<StakedNodesSummary | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [claimingNodes, setClaimingNodes] = useState<Set<string>>(new Set());
  const currentAddressRef = useRef<string>('');
  const stakingContractAddress = '0xa7C67D49C82c7dc1B73D231640B2e4d0661D37c1';

  const fetchStakingData = useCallback(async (address: string) => {
    if (!address || address === currentAddressRef.current) {
      return;
    }

    if (currentAddressRef.current !== address) {
      setStakingSummary(null);
      setError(null);
    }

    currentAddressRef.current = address;
    setLoading(true);

    try {
      const checker = new ZilliqaStakeChecker();
      const data = await checker.getStakedNodes(address);
      
      if (currentAddressRef.current === address) {
        setStakingSummary(data);
        setError(null);
      }
    } catch (err: any) {
      if (currentAddressRef.current === address) {
        setError(err.message || 'Failed to fetch staking data.');
        setStakingSummary(null);
      }
    } finally {
      if (currentAddressRef.current === address) {
        setLoading(false);
      }
    }
  }, []);

  useEffect(() => {
    if (wallet?.base16) {
      fetchStakingData(wallet.base16);
      setManualWalletAddress('');
    } else {
      currentAddressRef.current = '';
      setStakingSummary(null);
      setError(null);
    }
  }, [wallet?.base16, fetchStakingData]);

  const handleClaimRewards = useCallback(async (ssnAddress: string) => {
    if (!wallet) {
      setError('Please connect your wallet to claim rewards.');
      return;
    }

    setClaimingNodes(prev => new Set(prev).add(ssnAddress));
    setError(null);

    try {
      const payload = {
        _tag: 'WithdrawStakeRewards',
        params: [
          {
            vname: 'ssnaddr',
            type: 'ByStr20',
            value: ssnAddress,
          },
        ],
      };

      const tx = await zilPay.callTransaction(
        stakingContractAddress, 
        payload, 
        undefined, 
        undefined, 
        100000
      );

      if (tx.ID) {
        updateTransactions(wallet.bech32, [
          { hash: tx.ID, confirmed: false, error: false },
        ]);
        
        if (wallet.base16) {
          setTimeout(() => fetchStakingData(wallet.base16), 2000);
        }
      }
    } catch (err: any) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–º–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∏ –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫
      console.error('Transaction failed or cancelled:', err);
      if (err.message && !err.message.includes('User rejected')) {
        setError(err.message || 'Failed to send transaction.');
      }
    } finally {
      // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —É–±–∏—Ä–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏
      setClaimingNodes(prev => {
        const newSet = new Set(prev);
        newSet.delete(ssnAddress);
        return newSet;
      });
    }
  }, [wallet, fetchStakingData]);

  const handleManualAddressChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setManualWalletAddress(event.target.value);
  }, []);

  const handleManualFetch = useCallback(() => {
    if (manualWalletAddress.trim()) {
      fetchStakingData(manualWalletAddress.trim());
    }
  }, [manualWalletAddress, fetchStakingData]);

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∞ —Å–∫–µ–ª–µ—Ç–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
  const renderSkeletonLoading = () => (
    <div className={`${styles.summaryContainer} animate-slide-up`}>
      <SkeletonSummary />
      <div className={styles.grid}>
        {Array.from({ length: 3 }).map((_, index) => (
          <div key={index} style={{ animationDelay: `${index * 0.1}s` }}>
            <SkeletonCard />
          </div>
        ))}
      </div>
    </div>
  );

  return (
    <div className={styles.container}>
      <Header />
      <main className={styles.main}>
        {!wallet && (
          <div className={`${styles.inputContainer} animate-slide-up`}>
            <input
              type="text"
              placeholder="Enter Zilliqa Address (0x...)"
              value={manualWalletAddress}
              onChange={handleManualAddressChange}
              className={styles.addressInput}
            />
            <button
              onClick={handleManualFetch}
              disabled={loading || !manualWalletAddress.trim()}
              className={styles.fetchButton}
            >
              {loading ? 'Loading...' : 'Check Stakes'}
            </button>
          </div>
        )}

        {error && <div className={`${styles.error} animate-scale-in`}>{error}</div>}

        {loading && renderSkeletonLoading()}

        {!loading && stakingSummary && (
          <div className={`${styles.summaryContainer} animate-slide-up`}>
            <h2 className={styles.summaryTitle}>Your Staking Portfolio</h2>

            <div className={styles.summaryStats}>
              <div className={`${styles.statCard} ${styles.totalStaked}`}>
                <div className={styles.statLabel}>Total Staked</div>
                <div
                  className={styles.statValue}
                  title={`${stakingSummary.totalStaked.toString()} Qa`}
                >
                  {formatQaWithUnit(stakingSummary.totalStaked)}
                </div>
              </div>

              <div className={`${styles.statCard} ${styles.totalRewards}`}>
                <div className={styles.statLabel}>Unclaimed Rewards</div>
                <div
                  className={styles.statValue}
                  title={`${stakingSummary.totalRewards.toString()} Qa`}
                >
                  {formatQaWithUnit(stakingSummary.totalRewards)}
                </div>
              </div>

              <div className={`${styles.statCard} ${styles.totalNodes}`}>
                <div className={styles.statLabel}>Active Nodes</div>
                <div className={styles.statValue}>{stakingSummary.totalNodes}</div>
              </div>
            </div>

            {stakingSummary.nodes.length > 0 ? (
              <div className={styles.grid}>
                {stakingSummary.nodes.map((node, index) => (
                  <div key={node.ssnAddress} style={{ animationDelay: `${index * 0.1}s` }}>
                    <StakingNode
                      node={node}
                      onClaim={handleClaimRewards}
                      onUnstake={() => console.log('Unstake from', node.ssnName)}
                      isClaimLoading={claimingNodes.has(node.ssnAddress)}
                    />
                  </div>
                ))}
              </div>
            ) : (
              <div className={`${styles.noStakes} animate-scale-in`}>
                <p>No active stakes found for this address.</p>
                <p>Start staking to see your portfolio here!</p>
              </div>
            )}
          </div>
        )}
      </main>
    </div>
  );
};

export default StakingPage;


```

`2zilmoon/app/store/settings.ts`:

```ts
import { Store } from 'react-stores';

export enum Themes {
  Light = 'light',
  Dark = 'dark',
}

interface SettingsState {
  theme: Themes;
}

const getInitialTheme = (): Themes => {
  if (typeof window !== 'undefined') {
    const savedTheme = window.localStorage.getItem('theme') as Themes;
    if (savedTheme && Object.values(Themes).includes(savedTheme)) {
      return savedTheme;
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏—Å—Ç–µ–º–Ω—É—é —Ç–µ–º—É
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return Themes.Dark;
    }
  }
  return Themes.Light;
};

export const $settings = new Store<SettingsState>({
  theme: getInitialTheme(),
});

export function updateSettingsStore(newState: SettingsState) {
  $settings.setState(newState);
  if (typeof window !== 'undefined') {
    window.localStorage.setItem('theme', newState.theme);
    document.documentElement.setAttribute('data-theme', newState.theme);
  }
}

export function initTheme() {
  if (typeof window !== 'undefined') {
    const theme = getInitialTheme();
    $settings.setState({ theme });
    document.documentElement.setAttribute('data-theme', theme);
  }
}


```

`2zilmoon/app/store/transactions.ts`:

```ts
import { Store } from 'react-stores';

export type Tx = {
  hash: string;
  confirmed: boolean;
  error: boolean;
};
export type Txs = {
  transactions: Tx[];
};

const initState: Txs = {
  transactions: [],
};

export const $transactions = new Store(initState);

export function updateTransactions(key: string, transactions: Tx[]) {
  const state = $transactions.state;
  state.transactions = transactions;
  $transactions.setState(state);
  window.localStorage.setItem(key, JSON.stringify(state));
}

```

`2zilmoon/app/store/wallet.tsx`:

```tsx
'use client';
import { Wallet } from '../lib/types';
import { createContext, useContext, useState, ReactNode, useCallback } from 'react';

interface WalletState {
  wallet: Wallet | null;
  setWallet: (wallet: Wallet | null) => void;
}

const WalletContext = createContext<WalletState | undefined>(undefined);

export const WalletProvider = ({ children }: { children: ReactNode }) => {
  const [wallet, setWalletState] = useState<Wallet | null>(null);

  const setWallet = useCallback((newWallet: Wallet | null) => {
    setWalletState(prevWallet => {
      if (!newWallet && !prevWallet) return prevWallet;
      if (!newWallet || !prevWallet) return newWallet;
      if (newWallet.base16 === prevWallet.base16) return prevWallet;
      return newWallet;
    });
  }, []);

  return (
    <WalletContext.Provider value={{ wallet, setWallet }}>
      {children}
    </WalletContext.Provider>
  );
};

export const useWallet = () => {
  const context = useContext(WalletContext);
  if (context === undefined) {
    throw new Error('useWallet must be used within a WalletProvider');
  }
  return context;
};


```

`2zilmoon/next.config.ts`:

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

```
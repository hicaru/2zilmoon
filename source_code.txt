Project Path: 2zilmoon

Source Tree:

```txt
2zilmoon
‚îú‚îÄ‚îÄ app
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StakingNode
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ZilPayConnect
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ modals
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ account
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AccountCard.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Modal.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Toggle.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TxCard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dex.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trim.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilliqa-stake-checker-client.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilliqa-stake-checker.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zilpay-base.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ zilpay.ts
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ store
‚îÇ       ‚îú‚îÄ‚îÄ settings.ts
‚îÇ       ‚îú‚îÄ‚îÄ transactions.ts
‚îÇ       ‚îî‚îÄ‚îÄ wallet.tsx
‚îî‚îÄ‚îÄ next.config.ts

```

`2zilmoon/app/components/Header/index.tsx`:

```tsx
'use client';

import { useStore } from 'react-stores';
import styles from './Header.module.css';
import { ZilPayConnect } from '../ZilPayConnect';
import { $settings, updateSettingsStore, Themes } from '../../store/settings';

const Header = () => {
  const settings = useStore($settings);

  const toggleTheme = () => {
    const newTheme = settings.theme === Themes.Light ? Themes.Dark : Themes.Light;
    updateSettingsStore({ ...settings, theme: newTheme });
    document.documentElement.setAttribute('data-theme', newTheme);
  };

  return (
    <header className={styles.header}>
      <div className={styles.container}>
        <h1 className={styles.logo}>2zilmoon</h1>
        <div className={styles.controls}>
          <button 
            className={styles.themeToggle}
            onClick={toggleTheme}
            aria-label="Toggle theme"
          >
            {settings.theme === Themes.Light ? 'üåô' : '‚òÄÔ∏è'}
          </button>
          <ZilPayConnect />
        </div>
      </div>
    </header>
  );
};

export default Header;


```

`2zilmoon/app/components/StakingNode/index.tsx`:

```tsx
'use client';

import styles from './StakingNode.module.css';
import { NodeStakeInfo } from '../../lib/zilliqa-stake-checker-client';
import { formatQaWithUnit, formatAddress, formatCommissionRate } from '../../lib/formatters';

interface StakingNodeProps {
  node: NodeStakeInfo;
  onClaim?: () => void;
  onUnstake?: () => void;
}

const StakingNode: React.FC<StakingNodeProps> = ({ node, onClaim, onUnstake }) => {
  const hasRewards = node.rewardsAmount > 0n;

  return (
    <div className={`${styles.card} animate-scale-in`}>
      <div className={styles.header}>
        <h3 className={styles.nodeName}>{node.ssnName}</h3>
        <span className={`${styles.statusBadge} ${
          node.status === '–ê–∫—Ç–∏–≤–µ–Ω' ? styles.statusActive : styles.statusInactive
        }`}>
          {node.status}
        </span>
      </div>
      
      <div className={styles.info}>
        <div className={styles.infoItem}>
          <span className={styles.infoLabel}>Node Address</span>
          <span className={`${styles.infoValue} ${styles.address}`} title={node.ssnAddress}>
            {formatAddress(node.ssnAddress, 8, 6)}
          </span>
        </div>
        
        <div className={styles.infoItem}>
          <span className={styles.infoLabel}>Commission Rate</span>
          <span className={`${styles.infoValue} ${styles.commission}`}>
            {formatCommissionRate(node.commissionRate)}
          </span>
        </div>
      </div>

      <div className={styles.metrics}>
        <div className={styles.metric}>
          <div className={styles.metricLabel}>Staked</div>
          <div className={`${styles.metricValue} ${styles.amount}`} 
               title={`${node.stakeAmount.toString()} Qa`}>
            {formatQaWithUnit(node.stakeAmount)}
          </div>
        </div>
        
        <div className={styles.metric}>
          <div className={styles.metricLabel}>Rewards</div>
          <div className={`${styles.metricValue} ${styles.rewards}`} 
               title={`${node.rewardsAmount.toString()} Qa`}>
            {formatQaWithUnit(node.rewardsAmount)}
          </div>
        </div>
      </div>
      
      <div className={styles.buttonContainer}>
        {hasRewards ? (
          <button 
            className={`${styles.button} ${styles.claimButton}`}
            onClick={onClaim}
          >
            Claim Rewards
          </button>
        ) : (
          <button 
            className={`${styles.button} ${styles.unstakeButton}`}
            onClick={onUnstake}
          >
            Unstake
          </button>
        )}
      </div>
    </div>
  );
};

export default StakingNode;


```

`2zilmoon/app/components/ZilPayConnect/index.tsx`:

```tsx
'use client';
import { useEffect, useState } from 'react';
import { useWallet } from '../../store/wallet';
import { zilPay } from '../../lib/zilpay';
import { formatAddress } from '../../lib/formatters';
import styles from './ZilPayConnect.module.css';

export const ZilPayConnect = () => {
  const { wallet, setWallet } = useWallet();
  const [connecting, setConnecting] = useState(false);

  useEffect(() => {
    zilPay.observable(setWallet);
  }, [setWallet]);

  const handleConnect = async () => {
    if (connecting) return;
    
    setConnecting(true);
    try {
      const connectedWallet = await zilPay.connect();
      if (connectedWallet) {
        setWallet(connectedWallet);
      }
    } catch (error) {
      console.error('Failed to connect:', error);
    } finally {
      setConnecting(false);
    }
  };

  return (
    <button 
      className={`${styles.connectButton} ${
        wallet ? styles.connected : connecting ? styles.connecting : ''
      }`}
      onClick={handleConnect}
      disabled={connecting}
    >
      {wallet ? (
        <>
          <span className={styles.statusDot}></span>
          {formatAddress(wallet.bech32)}
        </>
      ) : connecting ? (
        'Connecting...'
      ) : (
        'Connect Wallet'
      )}
    </button>
  );
};


```

`2zilmoon/app/components/modals/account/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import { useStore } from "react-stores";
import { useTranslation } from "next-i18next";

import { Modal, ModalHeader } from "@/components/ui/Modal";
import { TxCard } from "@/components/ui/TxCard";
import { $transactions, resetTransactions } from "@/store/transactions";
import { AccountCard } from "@/components/ui/AccountCard";

import type { Wallet } from "@/lib/types";
import { $wallet } from "@/store/wallet";
import { Toggle } from "@/components/ui/Toggle";
import { $settings, updateSettingsStore } from "@/store/settings";
import { Themes } from "@/store/settings";

type Prop = {
  show: boolean;
  address: Wallet | null;
  onClose: () => void;
};


export var AccountModal: React.FC<Prop> = function ({
  show,
  onClose,
  address
}) {
  const common = useTranslation(`common`);
  const { transactions } = useStore($transactions);
  const wallet = useStore($wallet);
  const settings = useStore($settings);

  const hanldeChangeTheme = React.useCallback((value: boolean) => {
    if (value) {
      updateSettingsStore({
        ...settings,
        theme: Themes.Dark
      });
    } else {
      updateSettingsStore({
        ...settings,
        theme: Themes.Light
      });
    }
  }, [settings]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`account`)}
        </ModalHeader>
      )}
      width="450px"
      onClose={onClose}
    >
      <AccountCard wallet={address} />
      <div className={styles.txlist}>
        <Toggle
          value={settings.theme === Themes.Dark}
          onToggle={hanldeChangeTheme}
        />
        {transactions.length === 0 ? (
          <p className={styles.here}>
            {common.t(`tx_appear_here`)}
          </p>
        ) : (
          <div>
            <div className={styles.header}>
              <p>
                {common.t(`recent_txns`)}
              </p>
              <p
                className={styles.clear}
                onClick={() => resetTransactions(String(wallet?.bech32))}
              >
                (
                {common.t(`clear_all`)}
                )
              </p>
            </div>
            {transactions.map((tx) => (
              <TxCard key={tx.hash} tx={tx} />
            ))}
          </div>
        )}
      </div>
    </Modal>
  );
};

```

`2zilmoon/app/components/ui/AccountCard.tsx`:

```tsx
import React from 'react';

interface AccountCardProps {
  wallet: any; // Replace 'any' with your actual wallet type
}

export const AccountCard: React.FC<AccountCardProps> = ({ wallet }) => {
  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
      <p>Address: {wallet?.bech32}</p>
      <p>Balance: ...</p>
    </div>
  );
};

```

`2zilmoon/app/components/ui/Modal.tsx`:

```tsx
import React from 'react';

interface ModalProps {
  show: boolean;
  title: React.ReactNode;
  width?: string;
  onClose: () => void;
}

export const Modal: React.FC<ModalProps> = ({ show, title, width, onClose, children }) => {
  if (!show) return null;

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 1000 }}>
      <div style={{ backgroundColor: 'white', padding: '20px', borderRadius: '8px', width: width || 'auto', position: 'relative' }}>
        {title}
        <button onClick={onClose} style={{ position: 'absolute', top: '10px', right: '10px', background: 'none', border: 'none', fontSize: '1.2em', cursor: 'pointer' }}>&times;</button>
        {children}
      </div>
    </div>
  );
};

interface ModalHeaderProps {
  onClose: () => void;
}

export const ModalHeader: React.FC<ModalHeaderProps> = ({ onClose, children }) => {
  return (
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
      <h2>{children}</h2>
    </div>
  );
};

```

`2zilmoon/app/components/ui/Toggle.tsx`:

```tsx
import React from 'react';

interface ToggleProps {
  value: boolean;
  onToggle: (value: boolean) => void;
}

export const Toggle: React.FC<ToggleProps> = ({ value, onToggle }) => {
  return (
    <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
      <input
        type="checkbox"
        checked={value}
        onChange={(e) => onToggle(e.target.checked)}
        style={{ marginRight: '8px' }}
      />
      <span>{value ? 'Dark Mode' : 'Light Mode'}</span>
    </label>
  );
};

```

`2zilmoon/app/components/ui/TxCard.tsx`:

```tsx
import React from 'react';

interface TxCardProps {
  tx: any; // Replace 'any' with your actual transaction type
}

export const TxCard: React.FC<TxCardProps> = ({ tx }) => {
  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
      <p>Hash: {tx.hash}</p>
      <p>Confirmed: {tx.confirmed ? 'Yes' : 'No'}</p>
      {tx.error && <p style={{ color: 'red' }}>Error: {tx.error}</p>}
    </div>
  );
};

```

`2zilmoon/app/layout.tsx`:

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { WalletProvider } from './store/wallet';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "2zilmoon",
  description: "Zilliqa Staking Migration",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <WalletProvider>
          {children}
        </WalletProvider>
      </body>
    </html>
  );
}


```

`2zilmoon/app/lib/dex.ts`:

```ts
export class DragonDex {
  updateTokens() {
    // Placeholder for updating tokens logic
    console.log('DragonDex: updateTokens called');
  }

  updateState() {
    // Placeholder for updating DEX state logic
    console.log('DragonDex: updateState called');
  }
}
```

`2zilmoon/app/lib/formatters.ts`:

```ts
// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Qa –≤ ZIL (1 ZIL = 10^12 Qa)
const QA_TO_ZIL = 1000000000000n;

export const formatQaToZil = (qa: bigint): string => {
  const zil = Number(qa) / Number(QA_TO_ZIL);
  
  if (zil === 0) return '0';
  
  const formatter = new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 0,
    maximumFractionDigits: zil < 1 ? 6 : 2,
  });
  
  return formatter.format(zil);
};

export const formatQaWithUnit = (qa: bigint, showUnit: boolean = true): string => {
  const zil = formatQaToZil(qa);
  return showUnit ? `${zil} ZIL` : zil;
};

export const formatLargeNumber = (value: bigint): string => {
  const num = Number(value);
  
  if (num >= 1e9) {
    return new Intl.NumberFormat('en-US', {
      notation: 'compact',
      compactDisplay: 'short',
      maximumFractionDigits: 2
    }).format(num);
  }
  
  return new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 0
  }).format(num);
};

export const formatAddress = (address: string, startChars: number = 6, endChars: number = 4): string => {
  if (!address || address.length <= startChars + endChars) {
    return address;
  }
  return `${address.substring(0, startChars)}...${address.substring(address.length - endChars)}`;
};

export const formatCommissionRate = (rate: bigint): string => {
  const rateNumber = Number(rate) / 10000000;
  return new Intl.NumberFormat('en-US', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(rateNumber / 100);
};

export const formatUSD = (amount: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
};


```

`2zilmoon/app/lib/trim.ts`:

```ts
export function trim(str: string, len = 10) {
  const half = Math.floor(len / 2);
  return `${str.slice(0, half)}...${str.slice(str.length - half, str.length)}`;
}

```

`2zilmoon/app/lib/types.ts`:

```ts
export interface Wallet {
  base16: string;
  bech32: string;
}

```

`2zilmoon/app/lib/zilliqa-stake-checker-client.ts`:

```ts
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è Mainnet
const MAINNET_CONFIG = {
    api: 'https://api.zilliqa.com',
    impl: '0xa7C67D49C82c7dc1B73D231640B2e4d0661D37c1',
    chainId: 1
};

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
export interface NodeStakeInfo {
    ssnName: string;
    ssnAddress: string;
    stakeAmount: bigint;
    rewardsAmount: bigint;
    commissionRate: bigint;
    status: string;
}

export interface BatchQueryResult {
    id: number;
    result: any;
    jsonrpc?: string;
}

export interface RewardCalculationData {
    lastRewardCycle: number;
    lastWithdrawCycleMap: any;
    stakeSsnPerCycleMaps: { [ssnAddress: string]: any };
    directDepositMaps: { [ssnAddress: string]: any };
    buffDepositMaps: { [ssnAddress: string]: any };
    delegStakePerCycleMaps: { [ssnAddress: string]: any };
}

export interface StakedNodesSummary {
    nodes: NodeStakeInfo[];
    totalStaked: bigint;
    totalRewards: bigint;
    totalNodes: number;
}

export class ZilliqaStakeChecker {
    private apiUrl: string;
    private implAddress: string;

    constructor() {
        this.apiUrl = MAINNET_CONFIG.api;
        this.implAddress = MAINNET_CONFIG.impl;
    }

    private async batchQuery(queries: Array<[string, string, any[]]>): Promise<BatchQueryResult[]> {
        if (queries.length === 0) return [];
        const requestBody = queries.map((query, index) => ({
            jsonrpc: '2.0',
            id: index + 1,
            method: 'GetSmartContractSubState',
            params: [
                query[0],
                query[1],
                query[2]
            ]
        }));

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: ${response.status} ${response.statusText}`);
            }

            const jsonResponse: BatchQueryResult[] | {error: any} = await response.json();
            
            if (!Array.isArray(jsonResponse)) {
                 if (jsonResponse.error) {
                    throw new Error(`–û—à–∏–±–∫–∞ RPC: ${jsonResponse.error.message}`);
                 }
                throw new Error('–û—Ç–≤–µ—Ç –æ—Ç API –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º, –∫–∞–∫ –æ–∂–∏–¥–∞–ª–æ—Å—å –¥–ª—è batch-–∑–∞–ø—Ä–æ—Å–∞.');
            }
            
            return jsonResponse.sort((a, b) => a.id - b.id);
            
        } catch (error) {
            throw error;
        }
    }

    private normalizeAddress(address: string): string {
        if (!/^0x[0-9a-f]{40}$/i.test(address)) {
            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–¥—Ä–µ—Å–∞: ${address}. –û–∂–∏–¥–∞–µ—Ç—Å—è hex-–∞–¥—Ä–µ—Å —Ñ–æ—Ä–º–∞—Ç–∞ 0x...`);
        }
        return address.toLowerCase();
    }

    private async calculateRewards(normalizedAddress: string, userDeposits: { [ssn: string]: string }, rewardData: RewardCalculationData): Promise<{ [ssnAddress: string]: bigint }> {
        const rewardsBySsn: { [ssnAddress: string]: bigint } = {};

        for (const ssnAddress of Object.keys(userDeposits)) {
            let totalSsnReward = 0n;

            try {
                const lastWithdrawCycle = parseInt(rewardData.lastWithdrawCycleMap?.last_withdraw_cycle_deleg?.[normalizedAddress]?.[ssnAddress] || '0');
                const cyclesToCalculate = [];
                for (let i = lastWithdrawCycle + 1; i <= rewardData.lastRewardCycle; i++) {
                    cyclesToCalculate.push(i);
                }

                if (cyclesToCalculate.length === 0) {
                    rewardsBySsn[ssnAddress] = 0n;
                    continue;
                }

                const delegStakePerCycleMap = new Map<number, bigint>();
                const directMap = rewardData.directDepositMaps[ssnAddress]?.direct_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};
                const buffMap = rewardData.buffDepositMaps[ssnAddress]?.buff_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};

                for (let cycle = 1; cycle <= rewardData.lastRewardCycle; cycle++) {
                    const c1 = cycle - 1;
                    const c2 = cycle - 2;
                    const dir_amt = BigInt(directMap[c1.toString()] || 0);
                    const buf_amt = BigInt(buffMap[c2.toString()] || 0);
                    const last_amt = delegStakePerCycleMap.get(c1) || 0n;
                    const total_amt = last_amt + dir_amt + buf_amt;
                    delegStakePerCycleMap.set(cycle, total_amt);
                }

                const ssnCycleInfoMap = rewardData.stakeSsnPerCycleMaps[ssnAddress]?.stake_ssn_per_cycle?.[ssnAddress] || {};

                for (const cycle of cyclesToCalculate) {
                    const cycleInfo = ssnCycleInfoMap[cycle];
                    if (!cycleInfo) continue;

                    const totalRewardsForCycle = BigInt(cycleInfo.arguments[1]);
                    const totalStakeForCycle = BigInt(cycleInfo.arguments[0]);
                    const delegStakeForCycle = delegStakePerCycleMap.get(cycle);

                    if (delegStakeForCycle && delegStakeForCycle > 0n && totalStakeForCycle > 0n) {
                        const cycleReward = (delegStakeForCycle * totalRewardsForCycle) / totalStakeForCycle;
                        totalSsnReward += cycleReward;
                    }
                }
            } catch (e) {
                totalSsnReward = 0n;
            }

            rewardsBySsn[ssnAddress] = totalSsnReward;
        }
        
        return rewardsBySsn;
    }

    async getStakedNodes(walletAddress: string): Promise<StakedNodesSummary> {
        const normalizedAddress = this.normalizeAddress(walletAddress);

        const initialQueries: Array<[string, string, any[]]> = [
            [this.implAddress, 'deposit_amt_deleg', [normalizedAddress]],
            [this.implAddress, 'ssnlist', []],
            [this.implAddress, 'lastrewardcycle', []],
            [this.implAddress, 'last_withdraw_cycle_deleg', [normalizedAddress]],
        ];

        try {
            const initialResults = await this.batchQuery(initialQueries);
            
            const depositsResult = initialResults[0]?.result;
            const ssnListResult = initialResults[1]?.result;
            const lastRewardCycleResult = initialResults[2]?.result;
            const lastWithdrawResult = initialResults[3]?.result;

            if (!depositsResult || !ssnListResult || !lastRewardCycleResult) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            }

            const userDeposits = depositsResult.deposit_amt_deleg?.[normalizedAddress];
            
            if (!userDeposits || Object.keys(userDeposits).length === 0) {
                return {
                    nodes: [],
                    totalStaked: 0n,
                    totalRewards: 0n,
                    totalNodes: 0,
                };
            }
            
            const ssnList = ssnListResult.ssnlist;
            if (!ssnList) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤');

            const rewardQueries: Array<[string, string, any[]]> = [];
            const stakedSsnAddresses = Object.keys(userDeposits);

            for (const ssnAddr of stakedSsnAddresses) {
                rewardQueries.push([this.implAddress, 'stake_ssn_per_cycle', [ssnAddr]]);
                rewardQueries.push([this.implAddress, 'direct_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'buff_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'deleg_stake_per_cycle', [normalizedAddress, ssnAddr]]);
            }

            const rewardQueryResults = await this.batchQuery(rewardQueries);
            
            const rewardData: RewardCalculationData = {
                lastRewardCycle: parseInt(lastRewardCycleResult.lastrewardcycle),
                lastWithdrawCycleMap: lastWithdrawResult,
                stakeSsnPerCycleMaps: {},
                directDepositMaps: {},
                buffDepositMaps: {},
                delegStakePerCycleMaps: {},
            };
            
            let queryIndex = 0;
            for (const ssnAddr of stakedSsnAddresses) {
                rewardData.stakeSsnPerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.directDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.buffDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.delegStakePerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
            }
            
            const rewardsBySsn = await this.calculateRewards(normalizedAddress, userDeposits, rewardData);

            const stakedNodes: NodeStakeInfo[] = [];
            let totalStaked = 0n;
            let totalRewards = 0n;

            for (const [ssnAddress, stakeAmountStr] of Object.entries(userDeposits)) {
                const ssnInfo = ssnList[ssnAddress];
                
                if (!ssnInfo) {
                    continue;
                }

                const ssnArgs = ssnInfo.arguments;
                const ssnName = ssnArgs[3] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                const commissionRate = BigInt(ssnArgs[7] || '0');
                const isActive = ssnArgs[0]?.constructor === 'True';
                const status = isActive ? '–ê–∫—Ç–∏–≤–µ–Ω' : '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω';
                
                const stakeAmount = BigInt(stakeAmountStr as string);
                const rewardsAmount = rewardsBySsn[ssnAddress] || 0n;
                
                totalStaked += stakeAmount;
                totalRewards += rewardsAmount;

                const nodeInfo: NodeStakeInfo = { ssnName, ssnAddress: `0x${ssnAddress}`, stakeAmount, rewardsAmount, commissionRate, status };
                stakedNodes.push(nodeInfo);
            }

            return {
                nodes: stakedNodes,
                totalStaked: totalStaked,
                totalRewards: totalRewards,
                totalNodes: stakedNodes.length,
            };

        } catch (error) {
            throw error;
        }
    }
}
```

`2zilmoon/app/lib/zilliqa-stake-checker.ts`:

```ts
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è Mainnet
const MAINNET_CONFIG = {
    api: 'https://api.zilliqa.com',
    impl: '0xa7C67D49C82c7dc1B73D231640B2e4d0661D37c1', // Mainnet staking contract
    chainId: 1
};

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
export interface NodeStakeInfo {
    ssnName: string;
    ssnAddress: string;
    stakeAmount: bigint;
    rewardsAmount: bigint;
    commissionRate: bigint;
    status: string;
}

// –≠—Ç–æ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–¥–µ–∞–ª—å–Ω–æ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ñ–æ—Ä–º–∞—Ç–æ–º –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ batch-–æ—Ç–≤–µ—Ç–µ
interface BatchQueryResult {
    id: number;
    result: any;
    jsonrpc?: string; // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã
}

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –¥–∞–Ω–Ω—ã—Ö, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω–∞–≥—Ä–∞–¥
interface RewardCalculationData {
    lastRewardCycle: number;
    lastWithdrawCycleMap: any;
    stakeSsnPerCycleMaps: { [ssnAddress: string]: any };
    directDepositMaps: { [ssnAddress: string]: any };
    buffDepositMaps: { [ssnAddress: string]: any };
    delegStakePerCycleMaps: { [ssnAddress: string]: any };
}

export class ZilliqaStakeChecker {
    private apiUrl: string;
    private implAddress: string;

    constructor() {
        this.apiUrl = MAINNET_CONFIG.api;
        this.implAddress = MAINNET_CONFIG.impl;
    }

    private async batchQuery(queries: Array<[string, string, any[]]>): Promise<BatchQueryResult[]> {
        if (queries.length === 0) return [];
        const startTime = performance.now();

        const requestBody = queries.map((query, index) => ({
            jsonrpc: '2.0',
            id: index + 1,
            method: 'GetSmartContractSubState',
            params: [
                query[0],
                query[1],
                query[2]
            ]
        }));

        try {
            console.log(` –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è batch –∑–∞–ø—Ä–æ—Å (${queries.length} –∑–∞–ø—Ä–æ—Å–æ–≤) —á–µ—Ä–µ–∑ fetch (—Å—Ç–∞–Ω–¥–∞—Ä—Ç JSON-RPC 2.0)...`);
            
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: ${response.status} ${response.statusText}`);
            }

            const jsonResponse: BatchQueryResult[] | {error: any} = await response.json();
            
            if (!Array.isArray(jsonResponse)) {
                 if (jsonResponse.error) {
                    throw new Error(`–û—à–∏–±–∫–∞ RPC: ${jsonResponse.error.message}`);
                 }
                throw new Error('–û—Ç–≤–µ—Ç –æ—Ç API –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º, –∫–∞–∫ –æ–∂–∏–¥–∞–ª–æ—Å—å –¥–ª—è batch-–∑–∞–ø—Ä–æ—Å–∞.');
            }

            const endTime = performance.now();
            console.log(`‚úÖ Batch –∑–∞–ø—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω –∑–∞ ${((endTime - startTime) / 1000).toFixed(2)}—Å`);
            
            return jsonResponse.sort((a, b) => a.id - b.id);
            
        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –≤ batch –∑–∞–ø—Ä–æ—Å–µ:', error);
            throw error;
        }
    }

    private normalizeAddress(address: string): string {
        if (!/^0x[0-9a-f]{40}$/i.test(address)) {
            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–¥—Ä–µ—Å–∞: ${address}. –û–∂–∏–¥–∞–µ—Ç—Å—è hex-–∞–¥—Ä–µ—Å —Ñ–æ—Ä–º–∞—Ç–∞ 0x...`);
        }
        return address.toLowerCase();
    }

    private async calculateRewards(normalizedAddress: string, userDeposits: { [ssn: string]: string }, rewardData: RewardCalculationData): Promise<{ [ssnAddress: string]: bigint }> {
        console.log(`
 –†–∞—Å—á–µ—Ç –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥ (–≤ Qa)...`);
        const rewardsBySsn: { [ssnAddress: string]: bigint } = {};

        for (const ssnAddress of Object.keys(userDeposits)) {
            let totalSsnReward = 0n;

            try {
                const lastWithdrawCycle = parseInt(rewardData.lastWithdrawCycleMap?.last_withdraw_cycle_deleg?.[normalizedAddress]?.[ssnAddress] || '0');
                const cyclesToCalculate = [];
                for (let i = lastWithdrawCycle + 1; i <= rewardData.lastRewardCycle; i++) {
                    cyclesToCalculate.push(i);
                }

                if (cyclesToCalculate.length === 0) {
                    rewardsBySsn[ssnAddress] = 0n;
                    continue;
                }

                const delegStakePerCycleMap = new Map<number, bigint>();
                const directMap = rewardData.directDepositMaps[ssnAddress]?.direct_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};
                const buffMap = rewardData.buffDepositMaps[ssnAddress]?.buff_deposit_deleg?.[normalizedAddress]?.[ssnAddress] || {};

                for (let cycle = 1; cycle <= rewardData.lastRewardCycle; cycle++) {
                    const c1 = cycle - 1;
                    const c2 = cycle - 2;
                    const dir_amt = BigInt(directMap[c1.toString()] || 0);
                    const buf_amt = BigInt(buffMap[c2.toString()] || 0);
                    const last_amt = delegStakePerCycleMap.get(c1) || 0n;
                    const total_amt = last_amt + dir_amt + buf_amt;
                    delegStakePerCycleMap.set(cycle, total_amt);
                }

                const ssnCycleInfoMap = rewardData.stakeSsnPerCycleMaps[ssnAddress]?.stake_ssn_per_cycle?.[ssnAddress] || {};

                for (const cycle of cyclesToCalculate) {
                    const cycleInfo = ssnCycleInfoMap[cycle];
                    if (!cycleInfo) continue;

                    const totalRewardsForCycle = BigInt(cycleInfo.arguments[1]);
                    const totalStakeForCycle = BigInt(cycleInfo.arguments[0]);
                    const delegStakeForCycle = delegStakePerCycleMap.get(cycle);

                    if (delegStakeForCycle && delegStakeForCycle > 0n && totalStakeForCycle > 0n) {
                        const cycleReward = (delegStakeForCycle * totalRewardsForCycle) / totalStakeForCycle;
                        totalSsnReward += cycleReward;
                    }
                }
            } catch (e) {
                console.error(`- –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –Ω–∞–≥—Ä–∞–¥ –¥–ª—è —É–∑–ª–∞ ${ssnAddress}:`, e);
                totalSsnReward = 0n;
            }

            rewardsBySsn[ssnAddress] = totalSsnReward;
        }
        
        console.log(`‚úÖ –†–∞—Å—á–µ—Ç –Ω–∞–≥—Ä–∞–¥ –∑–∞–≤–µ—Ä—à–µ–Ω.`);
        return rewardsBySsn;
    }

    async getStakedNodes(walletAddress: string): Promise<NodeStakeInfo[]> {
        console.log(`
 –ü–æ–∏—Å–∫ —Å—Ç–µ–π–∫–æ–≤ –¥–ª—è –∞–¥—Ä–µ—Å–∞: ${walletAddress}`);
        const normalizedAddress = this.normalizeAddress(walletAddress);
        console.log(` –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å: ${normalizedAddress}`);

        const initialQueries: Array<[string, string, any[]]> = [
            [this.implAddress, 'deposit_amt_deleg', [normalizedAddress]],
            [this.implAddress, 'ssnlist', []],
            [this.implAddress, 'lastrewardcycle', []],
            [this.implAddress, 'last_withdraw_cycle_deleg', [normalizedAddress]],
        ];

        try {
            const initialResults = await this.batchQuery(initialQueries);
            
            const depositsResult = initialResults[0]?.result;
            const ssnListResult = initialResults[1]?.result;
            const lastRewardCycleResult = initialResults[2]?.result;
            const lastWithdrawResult = initialResults[3]?.result;

            if (!depositsResult || !ssnListResult || !lastRewardCycleResult) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            }

            const userDeposits = depositsResult.deposit_amt_deleg?.[normalizedAddress];
            
            if (!userDeposits || Object.keys(userDeposits).length === 0) {
                console.log('‚ùå –£ –¥–∞–Ω–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç–µ–π–∫–æ–≤');
                return [];
            }
            
            const ssnList = ssnListResult.ssnlist;
            if (!ssnList) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤');

            const rewardQueries: Array<[string, string, any[]]> = [];
            const stakedSsnAddresses = Object.keys(userDeposits);

            for (const ssnAddr of stakedSsnAddresses) {
                rewardQueries.push([this.implAddress, 'stake_ssn_per_cycle', [ssnAddr]]);
                rewardQueries.push([this.implAddress, 'direct_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'buff_deposit_deleg', [normalizedAddress, ssnAddr]]);
                rewardQueries.push([this.implAddress, 'deleg_stake_per_cycle', [normalizedAddress, ssnAddr]]);
            }

            const rewardQueryResults = await this.batchQuery(rewardQueries);
            
            const rewardData: RewardCalculationData = {
                lastRewardCycle: parseInt(lastRewardCycleResult.lastrewardcycle),
                lastWithdrawCycleMap: lastWithdrawResult,
                stakeSsnPerCycleMaps: {},
                directDepositMaps: {},
                buffDepositMaps: {},
                delegStakePerCycleMaps: {},
            };
            
            let queryIndex = 0;
            for (const ssnAddr of stakedSsnAddresses) {
                rewardData.stakeSsnPerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.directDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.buffDepositMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
                rewardData.delegStakePerCycleMaps[ssnAddr] = rewardQueryResults[queryIndex++]?.result;
            }
            
            const rewardsBySsn = await this.calculateRewards(normalizedAddress, userDeposits, rewardData);

            console.log(`
 –ù–∞–π–¥–µ–Ω–æ —Å—Ç–µ–π–∫–æ–≤ –Ω–∞ ${Object.keys(userDeposits).length} —É–∑–ª–∞—Ö:`);
            console.log('='.repeat(81));

            const stakedNodes: NodeStakeInfo[] = [];
            let totalStaked = 0n;
            let totalRewards = 0n;

            for (const [ssnAddress, stakeAmountStr] of Object.entries(userDeposits)) {
                const ssnInfo = ssnList[ssnAddress];
                
                if (!ssnInfo) {
                    console.log(`‚ö†Ô∏è  –£–∑–µ–ª 0x${ssnAddress} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ`);
                    continue;
                }

                const ssnArgs = ssnInfo.arguments;
                const ssnName = ssnArgs[3] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                const commissionRate = BigInt(ssnArgs[7] || '0');
                const isActive = ssnArgs[0]?.constructor === 'True';
                const status = isActive ? '–ê–∫—Ç–∏–≤–µ–Ω' : '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω';
                
                const stakeAmount = BigInt(stakeAmountStr as string);
                const rewardsAmount = rewardsBySsn[ssnAddress] || 0n;
                
                totalStaked += stakeAmount;
                totalRewards += rewardsAmount;

                const nodeInfo: NodeStakeInfo = { ssnName, ssnAddress: `0x${ssnAddress}`, stakeAmount, rewardsAmount, commissionRate, status };
                stakedNodes.push(nodeInfo);

                console.log(`
 –£–∑–µ–ª: ${ssnName}`);
                console.log(`     –ê–¥—Ä–µ—Å: 0x${ssnAddress}`);
                console.log(`     –°—Ç–µ–π–∫ (Qa): ${stakeAmount.toString()}`);
                console.log(`     –ù–∞–≥—Ä–∞–¥—ã (Qa): ${rewardsAmount.toString()}`);
                console.log(`     –ö–æ–º–∏—Å—Å–∏—è (10^7): ${commissionRate.toString()}`);
                console.log(`     –°—Ç–∞—Ç—É—Å: ${status}`);
            }

            console.log(`
${'='.repeat(81)}`);
            console.log(` –û–ë–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:`);
            console.log(`     –í—Å–µ–≥–æ —É–∑–ª–æ–≤ —Å–æ —Å—Ç–µ–π–∫–æ–º: ${stakedNodes.length}`);
            console.log(`     –û–±—â–∞—è —Å—É–º–º–∞ —Å—Ç–µ–π–∫–∞ (Qa): ${totalStaked.toString()}`);
            console.log(`     –û–±—â–∞—è —Å—É–º–º–∞ –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥ (Qa): ${totalRewards.toString()}`);
            console.log(`     –°–µ—Ç—å: Mainnet`);
            console.log('='.repeat(81));

            return stakedNodes;

        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–µ–π–∫–æ–≤:', error);
            throw error;
        }
    }
}
```

`2zilmoon/app/lib/zilpay-base.ts`:

```ts
import { ZilPay } from "@zilliqa-js/zilliqa";

export class ZilPayBase {
  public zilpay = () => new ZilPay();
}

```

`2zilmoon/app/lib/zilpay.ts`:

```ts
'use client';
import { Wallet } from './types';

declare global {
  interface Window {
    zilPay: any;
  }
}

export const zilPay = {
  crypto: {
    fromBech32Address: (bech32Address: string) => {
      if (typeof window === 'undefined' || !window.zilPay || !window.zilPay.crypto) {
        throw new Error('ZilPay crypto object not available.');
      }
      return window.zilPay.crypto.fromBech32Address(bech32Address);
    },
  },
  connect: async (): Promise<Wallet | null> => {
    try {
      const zilPay = await getZilPay();
      const connected = await zilPay.wallet.connect();
      if (connected && zilPay.wallet.defaultAccount) {
        return zilPay.wallet.defaultAccount;
      }
      return null;
    } catch (error) {
      console.error('Failed to connect to ZilPay:', error);
      return null;
    }
  },
  observable: (callback: (wallet: Wallet | null) => void) => {
    getZilPay().then((zilPay) => {
      if (zilPay.wallet.defaultAccount) {
        callback(zilPay.wallet.defaultAccount);
      }
      zilPay.wallet.observableAccount().subscribe((account: Wallet) => {
        callback(account);
      });
    });
  },
};

function getZilPay(): Promise<any> {
  return new Promise((resolve, reject) => {
    if (typeof window === 'undefined') {
      return reject('Window is not defined');
    }
    let k = 0;
    const i = setInterval(() => {
      if (k >= 10) {
        clearInterval(i);
        return reject(new Error(`ZilPay is not installed.`));
      }
      if (typeof window.zilPay !== `undefined`) {
        clearInterval(i);
        return resolve(window.zilPay);
      }
      k++;
    }, 100);
  });
}

```

`2zilmoon/app/page.tsx`:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { useWallet } from './store/wallet';
import Header from './components/Header';
import StakingNode from './components/StakingNode';
import styles from './page.module.css';
import { ZilliqaStakeChecker, StakedNodesSummary } from './lib/zilliqa-stake-checker-client';
import { formatQaWithUnit } from './lib/formatters';

const StakingPage = () => {
  const { wallet } = useWallet();
  const [manualWalletAddress, setManualWalletAddress] = useState<string>('');
  const [stakingSummary, setStakingSummary] = useState<StakedNodesSummary | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const fetchStakingData = async (address: string) => {
    if (!address) {
      setError('Please enter a wallet address or connect ZilPay.');
      setStakingSummary(null);
      return;
    }

    setLoading(true);
    setError(null);
    setStakingSummary(null);

    try {
      const checker = new ZilliqaStakeChecker();
      const data = await checker.getStakedNodes(address);
      setStakingSummary(data);
    } catch (err: any) {
      setError(err.message || 'Failed to fetch staking data.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (wallet && wallet.bech32) {
      try {
        fetchStakingData(wallet.base16);
        setManualWalletAddress(''); // Clear manual input when wallet connects
      } catch (e: any) {
        setError(`Error converting address: ${e.message}`);
      }
    } else {
      setStakingSummary(null);
    }
  }, [wallet]);

  const handleManualAddressChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setManualWalletAddress(event.target.value);
  };

  const handleManualFetch = () => {
    fetchStakingData(manualWalletAddress);
  };

  return (
    <div className={styles.container}>
      <Header />
      <main className={styles.main}>
        <div className={`${styles.hero} animate-fade-in`}>
          <h1 className={styles.title}>2zilmoon</h1>
          <p className={styles.description}>
            Seamless Zilliqa Staking Management - Track, Claim, and Migrate Your Stakes
          </p>
        </div>

        {!wallet && (
          <div className={`${styles.inputContainer} animate-slide-up`}>
            <input
              type="text"
              placeholder="Enter Zilliqa Address (0x...)"
              value={manualWalletAddress}
              onChange={handleManualAddressChange}
              className={styles.addressInput}
            />
            <button 
              onClick={handleManualFetch} 
              disabled={loading} 
              className={styles.fetchButton}
            >
              {loading ? 'Loading...' : 'Check Stakes'}
            </button>
          </div>
        )}

        {error && (
          <div className={`${styles.error} animate-scale-in`}>
            {error}
          </div>
        )}

        {loading && (
          <div className={`${styles.loading} animate-fade-in`}>
            <div className={styles.loadingSpinner}></div>
            <p>Fetching your staking data...</p>
          </div>
        )}

        {stakingSummary && (
          <div className={`${styles.summaryContainer} animate-slide-up`}>
            <h2 className={styles.summaryTitle}>Your Staking Portfolio</h2>
            
            <div className={styles.summaryStats}>
              <div className={`${styles.statCard} ${styles.totalStaked}`}>
                <div className={styles.statLabel}>Total Staked</div>
                <div className={styles.statValue} title={`${stakingSummary.totalStaked.toString()} Qa`}>
                  {formatQaWithUnit(stakingSummary.totalStaked)}
                </div>
              </div>
              
              <div className={`${styles.statCard} ${styles.totalRewards}`}>
                <div className={styles.statLabel}>Unclaimed Rewards</div>
                <div className={styles.statValue} title={`${stakingSummary.totalRewards.toString()} Qa`}>
                  {formatQaWithUnit(stakingSummary.totalRewards)}
                </div>
              </div>
              
              <div className={`${styles.statCard} ${styles.totalNodes}`}>
                <div className={styles.statLabel}>Active Nodes</div>
                <div className={styles.statValue}>
                  {stakingSummary.totalNodes}
                </div>
              </div>
            </div>

            {stakingSummary.nodes.length > 0 ? (
              <div className={styles.grid}>
                {stakingSummary.nodes.map((node, index) => (
                  <div key={node.ssnAddress} style={{ animationDelay: `${index * 0.1}s` }}>
                    <StakingNode 
                      node={node} 
                      onClaim={() => console.log('Claim rewards for', node.ssnName)}
                      onUnstake={() => console.log('Unstake from', node.ssnName)}
                    />
                  </div>
                ))}
              </div>
            ) : (
              <div className={`${styles.noStakes} animate-scale-in`}>
                <p>No active stakes found for this address.</p>
                <p>Start staking to see your portfolio here!</p>
              </div>
            )}
          </div>
        )}
      </main>
    </div>
  );
};

export default StakingPage;


```

`2zilmoon/app/store/settings.ts`:

```ts
import { Store } from 'react-stores';

export enum Themes {
  Light = 'light',
  Dark = 'dark',
}

interface SettingsState {
  theme: Themes;
}

export const $settings = new Store<SettingsState>({
  theme: Themes.Light,
});

export function updateSettingsStore(newState: SettingsState) {
  $settings.setState(newState);
}

```

`2zilmoon/app/store/transactions.ts`:

```ts
import createStore from 'react-stores';

export type Tx = {
  hash: string;
  confirmed: boolean;
  error: boolean;
};

export type Txs = {
  transactions: Tx[];
};

const initState: Txs = {
  transactions: [],
};

export const $transactions = createStore(initState);

export function updateTransactions(key: string, transactions: Tx[]) {
  const state = $transactions.state;
  state.transactions = transactions;
  $transactions.setState(state);
  window.localStorage.setItem(key, JSON.stringify(state));
}

```

`2zilmoon/app/store/wallet.tsx`:

```tsx
'use client';
import { Wallet } from '../lib/types';
import { createContext, useContext, useState, ReactNode } from 'react';

interface WalletState {
  wallet: Wallet | null;
  setWallet: (wallet: Wallet | null) => void;
}

const WalletContext = createContext<WalletState | undefined>(undefined);

export const WalletProvider = ({ children }: { children: ReactNode }) => {
  const [wallet, setWallet] = useState<Wallet | null>(null);

  return (
    <WalletContext.Provider value={{ wallet, setWallet }}>
      {children}
    </WalletContext.Provider>
  );
};

export const useWallet = () => {
  const context = useContext(WalletContext);
  if (context === undefined) {
    throw new Error('useWallet must be used within a WalletProvider');
  }
  return context;
};

```

`2zilmoon/next.config.ts`:

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

```